crystal_doc_search_index_callback({"repository_name":"puppy","body":"# puppy\n\n[API DOC](https://lost22git.github.io/puppy.cr)\n\nTODO: Write a description here\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     puppy:\n       github: lost22git/puppy.cr\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"puppy\"\n```\n\nTODO: Write usage instructions here\n\n## Development\n\nTODO: Write development instructions here\n\n## Contributing\n\n1. Fork it (<https://github.com/lost22git/puppy.cr/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [lost](https://github.com/lost22git) - creator and maintainer\n","program":{"html_id":"puppy/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"locations":[],"repository_name":"puppy","program":true,"enum":false,"alias":false,"const":false,"types":[{"html_id":"puppy/Puppy","path":"Puppy.html","kind":"module","full_name":"Puppy","name":"Puppy","abstract":false,"locations":[{"filename":"src\\puppy.cr","line_number":12,"url":"https://github.com/lost22git/puppy.cr/blob/f7c552cd53c9f28a85afa9fa4980ec9106628629/src\\puppy.cr#L12"},{"filename":"src\\puppy\\lib_winhttp.cr","line_number":6,"url":"https://github.com/lost22git/puppy.cr/blob/f7c552cd53c9f28a85afa9fa4980ec9106628629/src\\puppy\\lib_winhttp.cr#L6"},{"filename":"src\\puppy\\version.cr","line_number":1,"url":"https://github.com/lost22git/puppy.cr/blob/f7c552cd53c9f28a85afa9fa4980ec9106628629/src\\puppy\\version.cr#L1"}],"repository_name":"puppy","program":false,"enum":false,"alias":false,"const":false,"constants":[{"id":"CRLF","name":"CRLF","value":"\"\\r\\n\""},{"id":"RESPONSE_BODY_INIT_SIZE","name":"RESPONSE_BODY_INIT_SIZE","value":"8 * 1024"},{"id":"RESPONSE_BODY_MAX_SIZE","name":"RESPONSE_BODY_MAX_SIZE","value":"16 * (1024 * 1024)"},{"id":"UA","name":"UA","value":"\"Puppy #{VERSION} by WinHttp\""}],"class_methods":[{"html_id":"fetch(req:HTTP::Request,timeout:Time::Span,proxy_addr:URI|Nil=nil,decompress:Bool=true,trust_all_certs:Bool=false):HTTP::Client::Response-class-method","name":"fetch","abstract":false,"args":[{"name":"req","external_name":"req","restriction":"HTTP::Request"},{"name":"timeout","external_name":"timeout","restriction":"Time::Span"},{"name":"proxy_addr","default_value":"nil","external_name":"proxy_addr","restriction":"URI | ::Nil"},{"name":"decompress","default_value":"true","external_name":"decompress","restriction":"Bool"},{"name":"trust_all_certs","default_value":"false","external_name":"trust_all_certs","restriction":"Bool"}],"args_string":"(req : HTTP::Request, timeout : Time::Span, proxy_addr : URI | Nil = nil, decompress : Bool = true, trust_all_certs : Bool = false) : HTTP::Client::Response","args_html":"(req : HTTP::Request, timeout : Time::Span, proxy_addr : URI | Nil = <span class=\"n\">nil</span>, decompress : Bool = <span class=\"n\">true</span>, trust_all_certs : Bool = <span class=\"n\">false</span>) : HTTP::Client::Response","location":{"filename":"src\\puppy.cr","line_number":29,"url":"https://github.com/lost22git/puppy.cr/blob/f7c552cd53c9f28a85afa9fa4980ec9106628629/src\\puppy.cr#L29"},"def":{"name":"fetch","args":[{"name":"req","external_name":"req","restriction":"HTTP::Request"},{"name":"timeout","external_name":"timeout","restriction":"Time::Span"},{"name":"proxy_addr","default_value":"nil","external_name":"proxy_addr","restriction":"URI | ::Nil"},{"name":"decompress","default_value":"true","external_name":"decompress","restriction":"Bool"},{"name":"trust_all_certs","default_value":"false","external_name":"trust_all_certs","restriction":"Bool"}],"return_type":"HTTP::Client::Response","visibility":"Public","body":"url = URI.parse(req.resource)\nscheme = url.scheme\nif !scheme\n  raise(Error.new(\"Failed to parse scheme from url: \" + url.to_s))\nend\nhost = url.host\nif !host\n  raise(Error.new(\"Failed to parse host from url: \" + url.to_s))\nend\nport = url.port || (URI.default_port(scheme))\nif !port\n  raise(Error.new(\"Failed to parse port from url: \" + url.to_s))\nend\nrequest_target = url.request_target\nbegin\n  if proxy_addr\n    proxy_flag = LibWinHttp::WINHTTP_ACCESS_TYPE_NAMED_PROXY\n    w_proxy_addr = proxy_addr.to_s.to_utf16\n  else\n    proxy_flag = LibWinHttp::WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY\n    w_proxy_addr = \"\".to_utf16\n  end\n  user_agent = (req.headers[\"user-agent\"]? || UA).to_utf16\n  hSession = LibWinHttp.WinHttpOpen(user_agent, proxy_flag, w_proxy_addr, nil, 0)\n  if !hSession\n    raise(Error.new(\"WinHttpOpen error: \" + LibC.GetLastError.to_s))\n  end\n  ms = timeout.total_milliseconds\n  if (LibWinHttp.WinHttpSetTimeouts(hSession, ms, ms, ms, ms)) == 0\n    raise(Error.new(\"WinHttpSetTimeouts error: \" + LibC.GetLastError.to_s))\n  end\n  hostname = host.to_utf16\n  hConnect = LibWinHttp.WinHttpConnect(hSession, hostname, port, 0)\n  if !hConnect\n    raise(Error.new(\"WinHttpConnect error: \" + LibC.GetLastError.to_s))\n  end\n  open_request_flags = 0\n  if scheme == \"https\"\n    open_request_flags = open_request_flags | LibWinHttp::WINHTTP_FLAG_SECURE\n  end\n  verb = req.method.upcase.to_utf16\n  object_name = request_target.to_utf16\n  dbg!(verb)\n  dbg!(object_name)\n  default_accept_type = \"*/*\".to_utf16\n  default_accept_types = [default_accept_type.to_unsafe]\n  hRequest = LibWinHttp.WinHttpOpenRequest(hConnect, verb, object_name, nil, nil, default_accept_types, open_request_flags)\n  if !hRequest\n    raise(Error.new(\"WinHttpOpenRequest error: \" + LibC.GetLastError.to_s))\n  end\n  request_headers_buf = req.headers.serialize.to_utf16\n  dbg!(req.headers.serialize)\n  if (LibWinHttp.WinHttpAddRequestHeaders(hRequest, request_headers_buf, -1, (  LibWinHttp::WINHTTP_ADDREQ_FLAG_ADD | LibWinHttp::WINHTTP_ADDREQ_FLAG_REPLACE))) == 0\n    raise(Error.new(\"WinHttpAddRequestHeaders error: \" + LibC.GetLastError.to_s))\n  end\n  request_body_buf = req.body.try(&.getb_to_end) || (Bytes.new(0))\n  request_body_buf_size = request_body_buf.size\n  dbg!(String.new(request_body_buf))\n  dbg!(request_body_buf_size)\n  if (LibWinHttp.WinHttpSendRequest(hRequest, nil, 0, request_body_buf, request_body_buf_size, request_body_buf_size, 0)) == 0\n    error = LibC.GetLastError\n    if trust_all_certs && ([LibWinHttp::ERROR_WINHTTP_SECURE_FAILURE, LibWinHttp::ERROR_INTERNET_INVALID_CA, LibWinHttp::ERROR_INTERNET_SEC_CERT_DATE_INVALID, LibWinHttp::ERROR_INTERNET_SEC_INVALID_CERT, LibWinHttp::ERROR_INTERNET_SEC_CERT_CN_INVALID, LibWinHttp::ERROR_INTERNET_SEC_CERT_NO_REV, LibWinHttp::ERROR_INTERNET_SEC_CERT_REV_FAILED, LibWinHttp::ERROR_INTERNET_SEC_CERT_REVOKED, LibWinHttp::ERROR_INTERNET_SEC_CERT_ERRORS].includes?(error))\n      security_flags : LibWinHttp::DWORD = ((LibWinHttp::SECURITY_FLAG_IGNORE_UNKNOWN_CA | LibWinHttp::SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE) | LibWinHttp::SECURITY_FLAG_IGNORE_CERT_CN_INVALID) | LibWinHttp::SECURITY_FLAG_IGNORE_CERT_DATE_INVALID\n      if (LibWinHttp.WinHttpSetOption(hRequest, LibWinHttp::WINHTTP_OPTION_SECURITY_FLAGS, pointerof(security_flags), sizeof(typeof(security_flags)))) == 0\n        raise(Error.new(\"WinHttpSetOption error: \" + LibC.GetLastError.to_s))\n      end\n      if (LibWinHttp.WinHttpSendRequest(hRequest, nil, 0, request_body_buf, request_body_buf_size, request_body_buf_size, 0)) == 0\n        raise(Error.new(\"WinHttpSendRequest error: \" + LibC.GetLastError.to_s))\n      end\n    else\n      raise(Error.new(\"WinHttpSendRequest error: \" + LibC.GetLastError.to_s))\n    end\n  end\n  if (LibWinHttp.WinHttpReceiveResponse(hRequest, nil)) == 0\n    raise(Error.new(\"WinHttpReceiveResponse error: \" + LibC.GetLastError.to_s))\n  end\n  status_code = uninitialized Int32\n  status_code_buf_size = (sizeof(LibWinHttp::DWORD)).to_u32\n  if (LibWinHttp.WinHttpQueryHeaders(hRequest, LibWinHttp::WINHTTP_QUERY_STATUS_CODE | LibWinHttp::WINHTTP_QUERY_FLAG_NUMBER, nil, pointerof(status_code), pointerof(status_code_buf_size), nil)) == 0\n    raise(Error.new(\"Read status code: WinHttpQueryHeaders error: \" + LibC.GetLastError.to_s))\n  end\n  dbg!(status_code)\n  response_headers_buf = uninitialized Slice(LibWinHttp::WCHAR)\n  response_headers_buf_size = uninitialized LibWinHttp::DWORD\n  LibWinHttp.WinHttpQueryHeaders(hRequest, LibWinHttp::WINHTTP_QUERY_RAW_HEADERS_CRLF, nil, nil, pointerof(response_headers_buf_size), nil)\n  error_code = LibC.GetLastError\n  if error_code == LibWinHttp::ERROR_INSUFFICIENT_BUFFER\n    response_headers_buf = Slice(LibWinHttp::WCHAR).new(response_headers_buf_size // 2)\n  else\n    raise(Error.new(\"Read response headers bytesize: WinHttpQueryHeaders error: \" + error_code.to_s))\n  end\n  dbg!(response_headers_buf_size)\n  if (LibWinHttp.WinHttpQueryHeaders(hRequest, LibWinHttp::WINHTTP_QUERY_RAW_HEADERS_CRLF, nil, response_headers_buf, pointerof(response_headers_buf_size), nil)) == 0\n    raise(Error.new(\"Read response headers: WinHttpQueryHeaders error: \" + error_code.to_s))\n  end\n  dbg!(String.from_utf16(response_headers_buf))\n  response_headers = parse_response_headers(response_headers_buf)\n  dbg!(response_headers)\n  if response_headers.size == 0\n    raise(Error.new(\"Failed to parsing response headers\"))\n  end\n  response_body_io = uninitialized IO\n  response_body_buf = Bytes.new(RESPONSE_BODY_INIT_SIZE)\n  total_read_size = 0\n  while true\n    read_size = uninitialized LibWinHttp::DWORD\n    to_read_size = response_body_buf.size - total_read_size\n    if (LibWinHttp.WinHttpReadData(hRequest, response_body_buf.to_unsafe + total_read_size, to_read_size, pointerof(read_size))) == 0\n      raise(Error.new(\"WinHttpReadData error: \" + LibC.GetLastError.to_s))\n    end\n    if read_size == 0\n      break\n    end\n    total_read_size = total_read_size + read_size\n    if total_read_size >= RESPONSE_BODY_MAX_SIZE\n      raise(Error.new(\"Failed to read response body, reach RESPONSE_BODY_MAX_SIZE: \" + RESPONSE_BODY_MAX_SIZE.to_s))\n    else\n      if total_read_size == response_body_buf.size\n        new_size = Math.min(total_read_size * 2, RESPONSE_BODY_MAX_SIZE)\n        response_body_buf = Bytes.new(response_body_buf.to_unsafe.realloc(new_size), new_size)\n      end\n    end\n  end\n  readable_response_body_buf = Bytes.new(response_body_buf.to_unsafe, total_read_size, read_only: true)\n  response_body_io = IO::Memory.new(readable_response_body_buf, writeable: false)\n  if decompress\n    content_encoding = response_headers[\"content-encoding\"]?\n    dbg!(content_encoding)\n    if content_encoding\n      response_body_io = decompress(response_body_io, format: content_encoding)\n    end\n  end\n  HTTP::Client::Response.new(status_code: status_code, headers: response_headers, body_io: response_body_io)\nensure\n  if hRequest\n    LibWinHttp.WinHttpCloseHandle(hRequest)\n  end\n  if hConnect\n    LibWinHttp.WinHttpCloseHandle(hConnect)\n  end\n  if hSession\n    LibWinHttp.WinHttpCloseHandle(hSession)\n  end\nend\n"}}],"types":[{"html_id":"puppy/Puppy/Error","path":"Puppy/Error.html","kind":"class","full_name":"Puppy::Error","name":"Error","abstract":false,"superclass":{"html_id":"puppy/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"puppy/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"puppy/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"puppy/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src\\puppy.cr","line_number":18,"url":"https://github.com/lost22git/puppy.cr/blob/f7c552cd53c9f28a85afa9fa4980ec9106628629/src\\puppy.cr#L18"}],"repository_name":"puppy","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"puppy/Puppy","kind":"module","full_name":"Puppy","name":"Puppy"}}]}]}})